#ifndef BOARD8x8_H
#define BOARD8x8_H

#include "types.h"
#include "piecetype.h"
#include "stalematecondition.h"

#include <list>
#include <string>

class Move;
class MoveList;

class Board8x8
{
public:
  Board8x8();

public:
  bool canBlackCastleKingSide() const;
  bool canBlackCastleQueenSide() const;
  bool canWhiteCastleKingSide() const;
  bool canWhiteCastleQueenSide() const;
  uint generateLegalMoves(MoveList & moveList);
  uint generateLegalMoves(uint row, uint col, MoveList & moveList);
  void getCastlingRights(uint & castlingRights) const;
  PieceType getPieceType(uint row, uint col) const;
  uint getBlackKingRow() const;
  uint getBlackKingCol() const;
  uint getWhiteKingRow() const;
  uint getWhiteKingCol() const;
  bool isBlackChecked() const;
  bool isBlackMated() const;
  bool isCellAttacked(uint row, uint col, bool isWhitePiece) const;
  bool isWhiteChecked() const;
  bool isWhiteMated() const;
  bool isWhiteToMove() const;
  bool makeMove(Move & newMove);
  void setPosition(const std::string & fenString);
  bool unmakeMove(Move & undoMove);

protected:
  bool isLegal() const;

private:
  void generateBishopMoves(uint row, uint col, MoveList & moveList);
  void generateBlackPawnMoves(uint row, uint col, MoveList & moveList);
  void generateCandidateMoves(MoveList & moveList);
  void generateCandidateMoves(uint row, uint col, MoveList & moveList);
  void generateKingMoves(uint row, uint col, MoveList & moveList);
  void generateKnightMoves(uint row, uint col, MoveList & moveList);
  void generateMoves(std::list<uint> & indexList, uint row, uint col, MoveList & moveList, bool isSlider);
  void generateRookMoves(uint row, uint col, MoveList & moveList);
  void generateQueenMoves(uint row, uint col, MoveList & moveList);
  void generateWhitePawnMoves(uint row, uint col, MoveList & moveList);
  uint getIndex(uint row, uint col) const;
  void getRowCol(uint index, uint & row, uint & col) const;
  void initBoard();
  void initMoves();
  void loadState();
  void saveState();
  void trimCandidateMoves(MoveList & candidateMoves, MoveList & legalMoves);

private:
  Board8x8(const Board8x8 &);
  Board8x8 & operator=(const Board8x8 &);

private:
  bool mBlackCastleKingSide;
  bool mBlackCastleQueenSide;
  bool mBlackChecked;
  bool mBlackEnPassant;
  bool mBlackMated;
  bool mStalemate;
  bool mWhiteChecked;
  bool mWhiteCastleKingSide;
  bool mWhiteCastleQueenSide;
  bool mWhiteEnPassant;
  bool mWhiteMated;
  bool mWhiteToMove;
  uint mEnPassantCaptureCol;
  uint mBlackKingRow;
  uint mBlackKingCol;
  uint mHalfMoveClock;
  uint mTotalBlackBishops;
  uint mTotalBlackKnights;
  uint mTotalBlackPawns;
  uint mTotalBlackPieces;
  uint mTotalBlackRooks;
  uint mTotalBlackQueens;
  uint mTotalPieces;
  uint mTotalWhiteBishops;
  uint mTotalWhiteKnights;
  uint mTotalWhitePawns;
  uint mTotalWhitePieces;
  uint mTotalWhiteRooks;
  uint mTotalWhiteQueens;
  uint mWhiteKingRow;
  uint mWhiteKingCol;
  StalemateCondition mStalemateCondition;
  std::list<uint> mSavedStates;          //!< List of saved states generated by makeMove
  std::list<uint> mRookMovesNorth[64];
  std::list<uint> mRookMovesSouth[64];
  std::list<uint> mRookMovesWest[64];
  std::list<uint> mRookMovesEast[64];
  std::list<uint> mBishopMovesNorthEast[64];
  std::list<uint> mBishopMovesSouthEast[64];
  std::list<uint> mBishopMovesNorthWest[64];
  std::list<uint> mBishopMovesSouthWest[64];
  std::list<uint> mKingMoves[64];
  std::list<uint> mKnightMoves[64];
  std::list<uint> mWhitePawnMoves[64];
  std::list<uint> mBlackPawnMoves[64];
  PieceType mPieceType[64];
};

#endif // BOARD8x8_H
